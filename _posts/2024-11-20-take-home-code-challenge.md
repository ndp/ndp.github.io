---
layout: post
title: "Take-home Code Challenge for Employers"
date: 2024-11-20
comments: false
tags:
- software development
- interviews
- hiring
- sarcasm
---
Welcome, and congratulations on making it to this exciting stage of the hiring process! I'm thrilled that you're considering having me join your team. To help me understand your problem-solving skills, technical proficiency, creativity, and collaborative dynamics, I've designed a take-home code challenge just for your team.

This challenge is your chance to showcase your team's coding abilities in a relaxed, real-world environment. I've crafted the problems to be both engaging and fun, so it won't seem like work. I'm looking forward to seeing what you come up with!

Please approach this as you would any internal project, including typical communication and code review processes. Note, the scope may be slightly larger than a typical code challenge, but if you leverage the whole team it will go fast.

## Submission Guidelines:

1. **Project Setup:** Provide clear instructions on how to set up and run the project locally.
2. **Collaboration:** Use a version control system (preferably Git). Include a commit history to demonstrate how tasks were divided and handled. This exercise is not just about the end product but also about showcasing your team’s work culture and communication.

## Timeline:

Please spend about 30 minutes to an hour. But you will be given two weeks, just in case.

## Evaluation Criteria:

I will use a secret rubric with numbers, which (since they're numbers) seem scientific. Unfortunately, they have not been shown to correlate to, well, anything.

Due to the number of jobs I am interested in, I'm not able to provide specific feedback on your submission.

## Technical Requirements:

- Use a front-end framework/library of your choice (e.g., React, Angular, Vue, Qt, JSF).
- Implement a back-end service using a technology stack you're comfortable with (e.g., VBScript, Node.js, Python, Ruby, Java), but ideally something different than the backend to show your breadth.
- Use a relational database (e.g., Oracle) to store user and task information.
- Include error handling and input validation.
- Write unit and integration tests.
- Deploy on your favorite cloud provider (e.g., Azure) using a CI/CD pipeline and Kubernetes.

## Project: The GitHub Analyzer

### Overview:
Develop an application that evaluates GitHub profiles. The goal is to technically assess job candidates based solely on their GitHub profile, in an automated way, and determine whether the candidate is a "good" fit or not for a job.

### Project Description:

Implement 3 or more of these:

1. **Emoji Usage Metric:** Analyze commit messages for the number of emojis used. The more emojis, the higher the score.
2. **Late Night Commits:** Track the number of commits made between midnight and 4 AM to gauge dedication.
3. **Commit Message Length:** Score based on the average length of commit messages. Longer messages indicate a love for storytelling.
4. **Random Buzzword Count:** Count the number of tech buzzwords in commit messages and documentation. Extra points for using “synergy,” “blockchain,” or “machine learning” in irrelevant contexts.
5. **File Renaming Index:** Measure how often files are renamed. Frequent renaming could indicate a quest for perfection.
6. **Comment-to-Code Ratio:** Assess the ratio of comments to actual code. A higher ratio often means the code is well-documented, which can make it easier to understand, especially for new developers or those maintaining the code in the future.
7. **Pull Request Drama:** Analyze the number of comments and discussions in pull requests. High activity suggests a love for drama or collaboration.
8. **Variable Name Length:** Reward candidates for the longest variable names. Because clearly, `supercalifragilisticexpialidociousVariableName` is better than `i`.
9. **Commit Poetry:** Evaluate commit messages based on their poetic qualities. Extra points for haikus, limericks, and sonnets.
10. **Tabs vs. Spaces Warfare:** Count the number of flame wars the candidate has engaged in over tabs vs. spaces. High engagement equals high passion, right?
11. **Easter Egg Density:** Measure the number of hidden Easter eggs in the codebase. More Easter eggs, more fun!
12. **Commit Frequency:** Check how many commits happen per hour. More commits == more productivity!
13. **Commented-Out Code Quantity:** Measure the amount of commented-out code. The more, the better, because YJMNI ("you just might need it").
14. **TODO Count:** Track the number of TODO comments left in the code. It shows they're planning for the future.
15. **ASCII Art Proficiency:** Evaluate how much ASCII art is present in the code comments. True talent lies in drawing within the code!
16. **Magic Number Usage:** The more hardcoded magic numbers in the code, the higher the score. `7` is more readable than `seven`, right?
17. **Make up your own!** Show me your creativity by coming up with your own revealing metrics.

