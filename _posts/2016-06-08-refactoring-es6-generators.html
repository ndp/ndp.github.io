---
layout: post
title: "Refactoring and Iterating on Generators"
date: 2016-06-08
comments: false
url: /2016/06/2016-06-08-refactoring-es6-generators.html
tags:
 - refactoring
 - music
 - ES6
 - sound
 - exploration
 - generators
 - coding
---

<div class='post'>
<article class="markdown-body entry-content" itemprop="text"> <p>In this post, I delve into writing the same  functionality in a  myriad of ways. In the process, I'll evaluate some trade-offs,  as well as try out generators of Javascript  ES6.</p><a name='more'></a><p>The problem I'm solving is simple: we're building an interaction that plays musical sounds based on the users' actions. The  details aren't important here, but I need to generate the  frequencies for six octaves of "A" notes. My pair programmer (Aila) and I write simply:</p> <div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">octaves</span> <span class="pl-k">=</span> [<span class="pl-c1">110</span>, <span class="pl-c1">220</span>, <span class="pl-c1">440</span>, <span class="pl-c1">880</span>, <span class="pl-c1">1760</span>, <span class="pl-c1">3520</span>]</pre></div> <h3>Refactor, pass I</h3> <p>This is OK, but not as maintainable as it should be. To change the  key of the notes, my future self willg  have to change all the  numbers. I’d rather express the underlying math if possible. </p> <p>Turns out that this can be done with an old fashion <code>for</code> loop.</p> <div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">octaves</span> <span class="pl-k">=</span> <span class="pl-en">buildOctaves</span>(<span class="pl-c1">110</span>, <span class="pl-c1">4000</span>) <span class="pl-c">// "110" is base/bass note</span><br /><br /><span class="pl-k">function</span> <span class="pl-en">buildOctaves</span>(<span class="pl-smi">lo</span>, <span class="pl-smi">hi</span>) {    <br />  <span class="pl-k">const</span> <span class="pl-c1">o</span> <span class="pl-k">=</span> []   <br />  <span class="pl-k">for</span> (<span class="pl-k">let</span> f <span class="pl-k">=</span> lo; f <span class="pl-k">&lt;</span> hi; f <span class="pl-k">*=</span> <span class="pl-c1">2</span>)     <br />    <span class="pl-smi">o</span>.<span class="pl-c1">push</span>(f)   <br />  <span class="pl-k">return</span> o<br /> } </pre></div> <p>That works. It's not super because of all the noise there-- the  temporary <code>const</code> and the <code>for</code>-loop hide the <code>* 2</code> which is the  essence of it. Does  recursive work better? No, but sometimes you don't know until you try:</p> <div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">buildOctavesRecursive</span>(<span class="pl-smi">lo</span>, <span class="pl-smi">hi</span>) {<br />  <span class="pl-k">return</span> (<span class="pl-k">function</span> <span class="pl-en">next</span>(<span class="pl-smi">f</span>) {<br />    <span class="pl-k">if</span> (f <span class="pl-k">&lt;</span> hi) {<br />      <span class="pl-k">const</span> <span class="pl-c1">n</span> <span class="pl-k">=</span> <span class="pl-en">next</span>(f<span class="pl-k">*</span><span class="pl-c1">2</span>)<br />      <span class="pl-k">return</span> n <span class="pl-k">?</span> [f].<span class="pl-c1">concat</span>(n) <span class="pl-k">:</span> [f]<br />    }<br />  })(lo)<br />}</pre></div> <h3>ES6</h3> <p>I’ve been using RxJS lately, and thought about using it. It's great  at generating sequences and would handle this fine. But RxJS's  sweet spot is asynchronous event streams, and this is much simpler.  In fact, it seems like a great fit for the new <em>iterators</em> and  <em>generators</em> functionality in ES6.</p> <p>I liked the idea of using the spread (<code>...</code>) operator to execute  the loop, to get rid of the <code>while</code> construct. I find some   examples of <a href="/ndp/dizzidotz/blob/master">building generators online</a>, and after realizing   I don't need to use <code>[Symbol.iterator]</code>, I get:</p> <div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">buildOctaves</span>(<span class="pl-smi">lo</span>, <span class="pl-smi">hi</span>) { <span class="pl-c">// from Generator, take II</span><br />  <span class="pl-k">const</span> <span class="pl-c1">iterator</span> <span class="pl-k">=</span> <span class="pl-k">function</span><span class="pl-k">*</span> () {<br />    <span class="pl-k">let</span> a <span class="pl-k">=</span> lo<br />    <span class="pl-k">while</span> (a <span class="pl-k">&lt;</span> hi) {<br />      <span class="pl-k">yield</span> a<br />      a <span class="pl-k">*=</span> <span class="pl-c1">2</span><br />    }<br />  }<br />  <span class="pl-k">return</span> [<span class="pl-k">...</span><span class="pl-en">iterator</span>()]<br />}</pre></div> <p>I still have a while loop, but this is readable and  transparent about the intent of the  code. I even like the inlined version:</p> <div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">buildOctavesGenerator</span>(<span class="pl-smi">lo</span>, <span class="pl-smi">hi</span>) {<br />  <span class="pl-k">return</span> [<span class="pl-k">...</span>(<span class="pl-k">function</span><span class="pl-k">*</span> () {<br />    <span class="pl-k">let</span> a <span class="pl-k">=</span> lo<br />    <span class="pl-k">while</span> (a <span class="pl-k">&lt;</span> hi) {<br />      <span class="pl-k">yield</span> a<br />      a <span class="pl-k">*=</span> <span class="pl-c1">2</span><br />    }<br />  })()]<br />}</pre></div> <p>It's nice that the different aspects of the logic are each on their own expressive line: </p> <ul><li><code>return [...function* () () {</code> -- <em>return an array generated by...</em></li><li><code>while (a &lt; hi)</code> -- <em>while our accumulator is below the limit</em></li><li><code>a *= 2</code> -- <em>multiply by two</em></li></ul> <p>A note about using new features: Admittedly if the new features of  Javascript are new to you, this is the <em>least</em> readable. But we need to be careful here. We need to  ask, is it hard to read because of unfamiliar language features, or how the logic is spelled out? With a few exceptions, we need to assume that the reader understands the features of the language. Otherwise, we go down the path of writing code for the least common denominator: we limit  ourselves to a small, arbitrary subset of  any programming language. (The exception of this is complex languages  like C++, where a style guide is needed to highlight which features   of the language that one particular project will use.)</p> <p>But I want to try one more pass, and see if the logic can be made  clearer.  The <code>while</code> and <code>yield</code> are a distraction from the simple math here. </p> <h3>Top down</h3> <p>To get at the most readable code, often you need to start with the  final desired <em>ideal</em> code. So I sketch out what this might look  like: </p> <div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">buildOctaves</span>(<span class="pl-smi">lo</span>, <span class="pl-smi">hi</span>) {<br />  <span class="pl-k">const</span> <span class="pl-c1">octaveIter</span> <span class="pl-k">=</span> <span class="pl-en">doubleIter</span>(lo)<br />  <span class="pl-k">const</span> <span class="pl-c1">notes</span> <span class="pl-k">=</span> <span class="pl-en">whileLessThan</span>(octaveIter, hi)   <br />  <span class="pl-k">return</span> [<span class="pl-k">...</span>notes]<br />} </pre></div> <p>The  whole octave math is based on doubling the lower octave, so  it makes sense as a basic generator to build upon. That needs to  be coupled with something to halt the iteration. </p> <p>The doubling iterator is obvious:</p> <div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">doubleIter</span> <span class="pl-k">=</span> <span class="pl-k">function</span><span class="pl-k">*</span> (<span class="pl-smi">x</span>) {<br />  <span class="pl-k">while</span> (<span class="pl-c1">true</span>) {<br />    <span class="pl-k">yield</span> x<br />    x <span class="pl-k">*=</span> <span class="pl-c1">2</span><br />  }<br />}</pre></div> <p>Nice! And the <code>whileLessThan</code> can be:</p> <div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">whileLessThan</span> <span class="pl-k">=</span> <span class="pl-k">function</span><span class="pl-k">*</span>(<span class="pl-smi">it</span>, <span class="pl-smi">max</span>) {<br />  <span class="pl-k">for</span> (x <span class="pl-k">of</span> it) {<br />    <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> max)<br />      <span class="pl-k">yield</span> x;<br />    <span class="pl-k">else</span><br />      <span class="pl-k">return</span><br />  }<br />}</pre></div> <p>This is okay, but I realized that this function is doing two  different things, and parameterizing the loop with a function allows us to do the same thing with functional composition:</p> <div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">takeWhile</span> <span class="pl-k">=</span> <span class="pl-k">function</span><span class="pl-k">*</span> (<span class="pl-smi">it</span>, <span class="pl-smi">fn</span>) {<br />  <span class="pl-k">for</span> (x <span class="pl-k">of</span> it) {<br />    <span class="pl-k">if</span> (<span class="pl-en">fn</span>(x))<br />      <span class="pl-k">yield</span> x;<br />    <span class="pl-k">else</span><br />      <span class="pl-k">return</span><br />  }<br />}<br /><br /><span class="pl-k">const</span> <span class="pl-c1">whileLessThan</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">it</span>, <span class="pl-smi">max</span>) {<br />  <span class="pl-k">return</span> <span class="pl-en">takeWhile</span>(it, (<span class="pl-smi">x</span>) <span class="pl-k">=&gt;</span> x <span class="pl-k">&lt;</span> max)<br />}</pre></div> <h3>Conclusion</h3> <p>For me, since the last few functions I extracted are semantically  clear and can be moved into a  library, the decomposed solution using the latest Javascript  generators really is the best one. It provides the  clearest abstraction of logic as well as the easiest refactor paths.</p> <p>What do you think?</p></article></div>
