---
layout: post
title: Exploring Dependency Injection in Javascript
date: '2013-07-07T22:57:00.000-07:00'
author: ndp
tags:
- software development
- design
- javascript
- exploration
- coffeescript
- tdd
- AngularJS
- coding
modified_time: '2013-07-07T23:01:32.482-07:00'
---

<p>  Over the last month I've been wrapping my head around Angular JS.   I ended up exploring Dependency Injection, and thought I'd share my experiments. </p><a name='more'></a><p>  Angular uses dependency injection everywhere.   Dependency Injection, or DI, means instead of using or looking up a service in   the global name space, it is passed into the code, or "injected."   In the early 2000s in the Java world, when the Spring dependency injection   framework came out, there was much rejoicing.   A very   basic example shows the principal:</p><script src="https://gist.github.com/ndp/5915878.js?file=example.coffee"></script><p><code>console</code> is passed in, instead of being referenced off the global object. The advantages are:</p><ol>  <li>A different console can be substituted. This is great for configuration,     as you can write use a file-based logger without any change to client code.     This is also good for testing,     as you can very easily send in a mock console. But for the testing use case, it     is less critical in Javascript than Java,     because in Javascript it's straightforward to     <a href="https://github.com/pivotal/jasmine/wiki/Spies">replace nearly any     function.</a>  </li>  <li>We are not accessing some global value anymore, so the code is more modular.   It can run in any environment, whether it has a global console or not. And if we   want to change what console does in one part of the code and not the other, we   have that level of control.</li></ol><p>The disadvantage is simply that you need to find the service and inject it.   Since passing services in everywhere becomes burdensome, DI frameworks   automate this injection. </p><p>  If you're familiar with the nodejs/require, you might think it's equivalent,   but it's not. The   require asks for a specific global resource explicitly. DI gives a level of   indirection and allows plug in different resources. </p> <h4>What Angular Dependency Injection Looks Like</h4><p>  Within Angular, dependencies are injected using function parameters.   This is a reasonable, functional language choice.   Angular is responsible for calling the function with those dependencies injected.   Let's say you have a couple services:    <script src="https://gist.github.com/ndp/5915878.js?file=services.coffee"></script> <p>Here's a third service that uses them:</p><script src="https://gist.github.com/ndp/5915878.js?file=angularStyleService.coffee"></script><p>It's easy to define, but there's some awkwardness here: a function that returns another function? Ugh. It takes a   while to be able to read through this code easily, since this pattern is nearly everywhere. </p><p>Now to call our service, we need it to be injected with its dependencies, which is also a little awkward, but   accomplished with an additional function wrapper:</p> <script src="https://gist.github.com/ndp/5915878.js?file=angularStyleInjectorSpec.coffee"></script> <h4>What Angular Dependency Injection REALLY Looks Like</h4>        <p>Quickly you run into different ways to         define functions within Angular. Since <a                 href="https://developers.google.com/closure/compiler/docs/compilation_levels">          Google's           Closure Compile</a>, and many other code compressors will rename parameters to           save a few bytes, this technique doesn't work. So the solution worked out was to           declare an array that lists the injected variables along with the function:</p>         <script src="https://gist.github.com/ndp/5915878.js?file=angularStyle2.coffee"></script><p>This ends up looking pretty awkward to my eye, and I was wondering if there was a better way.</p>        <p>Well, first I had to deconstruct how Angular does it.</p>  <h4>How the magic is implemented</h4><p>  How this works is interesting.   The secret behind all of this is something I found a little counter-intuitive: when you   call <code>toString</code> on a function object, you get the actual text of the function. For example here is a useful   function:</p> <script src="https://gist.github.com/ndp/5915878.js?file=fnTextWithoutComments.coffee"></script> <blockquote>(Below are snippets of <em>my code</em>, not Angular, although much is based   on techniques   in   Angular code.)</blockquote><p>  For DI, Angular needs to know the argument names. In order to figure this out, Angular uses regular expressions. I   found other DI frameworks that build a parse tree to identify these, but in this case, a regular expression suffices.   I extracted Angular logic into its own function:</p> <script src="https://gist.github.com/ndp/5915878.js?file=argumentNames.coffee"></script><p>  The final piece is to put it together: figure out the arguments and then call the function with the correct   services:</p> <script src="https://gist.github.com/ndp/5915878.js?file=angularStyleInjector.coffee"></script> <p>  For DI, you need some way to discover the objects that are injected. I think   this works well as a separate concept, so I define a stub service locator, which given   a name, returns the right service: </p> <script src="https://gist.github.com/ndp/5915878.js?file=serviceLocator.coffee"></script>   <h4>Alternative Technique #1</h4> <p>  So I wondered is there a more concise way to do this dependency injection.   Creating a whole new function just to set the injected variables seemed like   overkill. I started noodling... a thing about Angular you notice right off   is the <code>$scope</code> object. It's an injected parameter that is used   to communicate between the controller and views. By having <code>$scope</code>,   most code doesn't use the <code>this</code> context object much.   Could we simply call the service with all the injected parameters   in a <code>this</code> context object?   (Yes, there are newer Angular approaches that use it more than most of the sample code,   but let's not worry about that, shall we?) </p><p>  The definition of the service is simpler.   There's no need for nested functions returning functions.   Simply reference variables associated with this context   or in Coffeescript, <code>@</code> variables: </p> <script src="https://gist.github.com/ndp/5915878.js?file=contextStyleInjectorService.coffee"></script> <p>  And the call is identical to the Angular style: </p> <script src="https://gist.github.com/ndp/5915878.js?file=contextStyleInjectorCall.coffee"></script>  <p>  The injector itself isn't more complicated than the angular one.   Using building blocks in the other parts of the code: </p> <script src="https://gist.github.com/ndp/5915878.js?file=contextStyleInjector.coffee"></script> <p>  It depends on this function <code>members</code>,   which looks through the whole function body for references off of <code>this</code>. </p><script src="https://gist.github.com/ndp/5915878.js?file=members.coffee"></script> <p>(Perhaps it's naive to think that this is going to work in practice. I'm not sure.   I do realize it will falsely match nested function references,   and "over-inject". And if <code>this</code> references are renamed <code>self</code> or   <code>that</code>, it's not going to work without modification.) </p><p>  In this implementation I'm not telling it what to inject, following the   Angular technique of sucking them out of the source code automatically. I see   a couple advantages over Angular's:   <ol>  <li>The definition is simpler, without functions returning functions. Although   identifying injected services is harder.</li>  <li>This technique is less susceptible to the drawbacks, as <a           href="https://developers.google.com/closure/compiler/docs/compilation_levels">    Google's     Closure Compile</a> will not rename properties in the SIMPLE_OPTIMIZATIONS mode.</li>  </ol> <h4>Experiment #2: Objects</h4><p>JavaScript has dual nature. It has functions,   but it also has objects.   So let's look at using an object as the base for injection.</p><p>(I'm going to avoid Coffeescript's <code>class</code>,   so as to avoid any questions as to how it behaves in reference   to raw Javascript. It should work well here, though.)</p> <p>We'll see both the object definition and the call:</p> <script src="https://gist.github.com/ndp/5915878.js?file=objectFnInjectorSpec.coffee"></script> <p>We will do what we just did in Experiment #1, but once for each function of an object.    <script src="https://gist.github.com/ndp/5915878.js?file=objectFnInjector.coffee"></script> <p>  We find all the functions   and then from there find all the needed services,   and inject them into the object. </p> <h4>Experiment #3: Explicit Objects</h4><p>The magic hunting around for function names isn't that comfortable,   we can be explicit.   In this definition of an object will simply indicate the names   of the services that are required, so it's clear they   need to be injected: </p> <script src="https://gist.github.com/ndp/5915878.js?file=explicitObjectInjectionSpec.coffee"></script> <p>If you are still with me, you should be able to appreciate the implementation:</p><script src="https://gist.github.com/ndp/5915878.js?file=explicitObjectInjection.coffee"></script> <h4>Conclusions?</h4><p>Dependency Injection will never be as important in Javascript as it is in Java, but still is a valuable tool.    </p><p>For Angular, I see how Experiment #1 is an interesting technique. But there are three, or maybe four techniques already in         use there, and to be honest, and adding another wouldn't help matters.         That ship has sailed. I like the technique nonetheless. <p><p>  For Coffeescript or pseudo-class system, one of the object-oriented   techniques will be natural. Experiment #3   would fit in very nicely with a BackBone app. </p>        <p>I'm sure there are other ways to do this...           this is my riffing on just one direction. What do you think?</p>