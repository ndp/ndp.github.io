---
layout: post
title: ""
date: 2016-01-15
comments: false
url: /2016/01/shh-algolia-for-win-sitting-in-our.html
tags:
 - search
 - software development
 - heroku
 - rails
 - ruby
 - ux
 - prototyping
---

<div class='post'>
<h2>Shh!&nbsp;<span class="s1">Algolia for the Win</span></h2><div class="p1"><span class="s1">Sitting in our dining room, discussing our kids’ room full of books, I decided to regale our kids with a story about the old days of the library: rows of “card catalogs," little pieces of paper to jot down call numbers, etc. This got them very excited, and they love building things, so they were gearing up to re-create just such a system in their bedroom.&nbsp;</span></div><div class="p2"><span class="s1"></span><br /><a name='more'></a><br /></div><div class="p1"><span class="s1">I waved my hands, “No, no, no, that’s not the point.” I’d show them the modern way: it's all online now. I'd toss together an Online Library Management System to help them share their books. Believe it or not, they weren’t excited-- but they agreed. Yeah, a search box would be neat.</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">Of course with <a href="http://rails.org/">Rails</a> and <a href="https://www.heroku.com/">Heroku</a> and my N years of experience, it was just an hour from idea to live, fully-functional app&nbsp;on the internet. We had CRUD screens for books, subjects, authors and even characters. I stood up and dusted&nbsp;my hands off proudly. Then my eldest daughter put on her PM hat, and reminded me of the requirements: “It’s just a search box.”&nbsp;</span></div><div class="p1"><span class="s1"><br /></span></div><div class="p1"><span class="s1">“Yeah, I know,” I said. “Soon.”&nbsp;</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">She'll be a hard-driving PM when she grows up. It was time to get search working. I looked at <a href="https://elements.heroku.com/addons#search">the current options available as Heroku plugins</a>. There were the old standards: Lucene, Solr, Elastic Search. I’d used them each on a couple projects and knew what they’d involve. I’d have to spend some time for them to provide nice results– tuning, weighting and very careful indexing. Do-able, but a lot like work.</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">There was an option that intrigued me. <a href="https://elements.heroku.com/addons/algoliasearch">Algolia</a> promised to be the “next generation," offering good searches from the first keystroke, with in-browser integration. This is something I explored a bit with <a href="http://amp-what.com/">&amp;What</a>, Algolia offered a small (&amp; free) plan, so I was off and running.</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">Getting started was easy. They offer simple <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">ActiveRecord</span> integration that looks similar to Elastic Search and Solr gems. (</span>You’re not limited to this-- there are several integrations in a host of languages. And of course the whole thing is just a JSON restful API, so you can write your own integration, if you want.)</div><div class="p1"><br /></div><div class="p1">My Rails integration was unsurprising:&nbsp;</div><blockquote class="tr_bq"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><i>class Book &lt; ActiveRecord::Base</i><span class="s2"><i>&nbsp; include </i></span><b><i>AlgoliaSearch<br /></i></b><span class="s2">&nbsp;&nbsp;</span>&nbsp; algoliasearch <span class="s3"><b>index_name</b></span>: <span class="s4"><b>"Book_</b></span><span class="s5">#{</span><span class="s3"><b><i>Rails</i></b></span>.env<span class="s5">}</span><span class="s4"><b>" </b></span><span class="s6"><b>do<br />&nbsp; &nbsp; &nbsp;</b></span><span class="s6"><b>&nbsp; &nbsp; &nbsp;</b></span><span class="s6"><b>&nbsp;&nbsp; &nbsp; </b></span><span class="s2"><i>attribute&nbsp; </i></span><b>:title</b><span class="s2">, </span><b>:author_name</b><span class="s2">, </span><b>:genre_name</b><span class="s2">,&nbsp;</span><span class="s2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><b>:subject_names</b><span class="s2">, </span><b>:character_names</b><span class="s2">,&nbsp;</span>&nbsp; &nbsp;</span><span style="font-family: Courier New, Courier, monospace;"><span style="font-family: Courier New, Courier, monospace;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="s3"><b><span style="font-family: Courier New, Courier, monospace;">:isbn</span>13</b></span></span></blockquote><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; <b>def</b> subjects_names</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subjects.map(&amp;:name)</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; <b>end</b></span><br /><span style="font-family: Courier New, Courier, monospace;"><b>&nbsp; &nbsp; &nbsp; &nbsp; ...</b></span><br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;"><span class="s3"><b></b></span><span class="s6"><b><span style="font-family: Courier New, Courier, monospace;">end</span></b></span></span></blockquote><div class="p1"><span class="s1">This declares which values are indexed. This block instrument's ActiveRecord’s <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">save</span> methods to capture all changes. There's nothing to install on your machine: the development model is to store everything in the cloud (hence the <span style="font-family: Courier New, Courier, monospace;">Rails.env</span> to keep the cloud index separate).</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">You can index whatever you want. Intuitively, each of those attribute symbols is a method that is called on the book object, and the result is stored in the index. You can write synthetic attributes, like <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">subject_names</span> is above, by writing your own method.&nbsp;</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">There are also facets. Although I didn't use these, they look more naturally integrated than they are in Solr and Elastic Search, where they feel like an add-on.&nbsp;</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">The documentation is very good. The Heroku page got me started, but when I decided to change direction, I found a recipe on their website that was clear and complete. I didn’t run into any roadblocks or inaccurate documentation.</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">On the query side, it’s also full-featured. They have solutions for browser-based queries in place, so it’s easy to integrate onto a page without touching your server:</span></div><blockquote class="tr_bq"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><span class="s6"><b>var </b></span><span class="s3"><b><i>helper </i></b></span>= algoliasearchHelper(algolia, INDEX_NAME, PARAMS);<br /><span class="s3"><b><i>helper</i></b></span>.<span class="s7">setQuery</span>(query).<span class="s7">search</span>();<br /><span class="s3"><b><i>helper</i></b></span>.<span class="s7">on</span>(<span class="s4"><b>'result'</b></span>, <span class="s6"><b>function </b></span>(content, state) { ...</span></blockquote><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">I was able to get my daughter’s “search box” working almost immediately, with a minimum of additional tools. The search results have highlighting and facets built in. Nice.</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">But there was one big surprise. I set up an index and indexed all 91 books (that were available in my seed spreadsheet). I saw the HTTP requests going through to create the index, and their website’s dashboard has a log and complete metrics. They also have a console webpage where you can test out your index. But my indexes didn’t appear. Wha? Not just the indexed items, but the indexes themselves. </span>&nbsp;I tried the Ruby API and raw HTTP requests, with no success. But other API calls said it had created the index. Any query call reported that there was no index, and the dashboard was empty. It felt really broken.&nbsp;</div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">There was a clue, though. Each API call returns a job ID. I realized that everything was being queued up to run in the background. No problem, but how long should it take? It had been 10 minutes. I checked their status page but there were no alerts. It might have been a bad moment for their servers— or maybe indexing 91 books on a free account just doesn't get priority. Well, Rome’s Library Management System wasn’t built in a day, so I shut my laptop and went to bed.</span></div><div class="p2"><br /></div><div class="p1"><span class="s1">When I awoke in the morning, my jobs had run and I had nice search results:</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p2"><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-9HuqMfzQ83c/VpmQTC13r0I/AAAAAAAALzA/BpAPWw8tdL4/s1600/Screen%2BShot%2B2015-12-29%2Bat%2B5.58.36%2BPM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://3.bp.blogspot.com/-9HuqMfzQ83c/VpmQTC13r0I/AAAAAAAALzA/BpAPWw8tdL4/s320/Screen%2BShot%2B2015-12-29%2Bat%2B5.58.36%2BPM.png" width="284" /></a></div><span class="s1"></span><br /></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">The search results are quite good from the get go. It really does instantaneous search. It also does “near” searches, stemming and all sorts of things I’m conditioned to having to take on as individual projects. For example, here’s a search for “Fate," which pulls up similar words:</span></div><div class="p2"><br /><span class="s1"></span></div><div class="p2"><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-07TYipqc8jw/VpmQZ0cx27I/AAAAAAAALzM/4O3dN6DwGLk/s1600/Screen%2BShot%2B2015-12-29%2Bat%2B5.55.51%2BPM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://4.bp.blogspot.com/-07TYipqc8jw/VpmQZ0cx27I/AAAAAAAALzM/4O3dN6DwGLk/s320/Screen%2BShot%2B2015-12-29%2Bat%2B5.55.51%2BPM.png" width="235" /></a></div><span class="s1"></span><br /></div><div class="p1"><span class="s1">Overall, I’m a big thumbs up. Give <a href="https://www.algolia.com/">Algolia</a> a shot.</span><br /><span class="s1"><br /></span><span class="s1">My only criticisms, which I've touched on above, are:</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p1"><span class="s1">(1) The Ruby API— and the API in general— is a leaky abstraction, as it tucks away the asynchronous processing. I'm not sure about this design choice, since it was obviously designed to be asynchronous from the beginning.</span></div><div class="p1"><span class="s1">(2) I wasn’t able to see what jobs were running or get estimates about when they would be done. In anything but a toy project, these stats are critical.</span></div><div class="p2"><span class="s1"></span><br /></div><div class="p2"><span class="s1"></span><br /></div><div class="p2"><span class="s1"></span><br /></div><br /><div class="p2"><span class="s1"></span><br /></div></div>
